{"version":3,"file":"actualizar-63b043bb.js","sources":["../../../../node_modules/nuxt/dist/app/composables/asyncData.js","../../../../stores/actualizar.ts"],"sourcesContent":["import { getCurrentInstance, onBeforeMount, onServerPrefetch, onUnmounted, ref, toRef, unref, watch } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { createError } from \"./error.js\";\nconst getDefault = () => null;\nexport function useAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  let [key, handler, options = {}] = args;\n  if (typeof key !== \"string\") {\n    throw new TypeError(\"[nuxt] [asyncData] key must be a string.\");\n  }\n  if (typeof handler !== \"function\") {\n    throw new TypeError(\"[nuxt] [asyncData] handler must be a function.\");\n  }\n  options.server = options.server ?? true;\n  options.default = options.default ?? getDefault;\n  options.lazy = options.lazy ?? false;\n  options.immediate = options.immediate ?? true;\n  const nuxt = useNuxtApp();\n  const getCachedData = () => nuxt.isHydrating ? nuxt.payload.data[key] : nuxt.static.data[key];\n  const hasCachedData = () => getCachedData() !== void 0;\n  if (!nuxt._asyncData[key]) {\n    nuxt._asyncData[key] = {\n      data: ref(getCachedData() ?? options.default?.() ?? null),\n      pending: ref(!hasCachedData()),\n      error: toRef(nuxt.payload._errors, key)\n    };\n  }\n  const asyncData = { ...nuxt._asyncData[key] };\n  asyncData.refresh = asyncData.execute = (opts = {}) => {\n    if (nuxt._asyncDataPromises[key]) {\n      if (opts.dedupe === false) {\n        return nuxt._asyncDataPromises[key];\n      }\n      nuxt._asyncDataPromises[key].cancelled = true;\n    }\n    if (opts._initial && hasCachedData()) {\n      return getCachedData();\n    }\n    asyncData.pending.value = true;\n    const promise = new Promise(\n      (resolve, reject) => {\n        try {\n          resolve(handler(nuxt));\n        } catch (err) {\n          reject(err);\n        }\n      }\n    ).then((_result) => {\n      if (promise.cancelled) {\n        return nuxt._asyncDataPromises[key];\n      }\n      let result = _result;\n      if (options.transform) {\n        result = options.transform(_result);\n      }\n      if (options.pick) {\n        result = pick(result, options.pick);\n      }\n      asyncData.data.value = result;\n      asyncData.error.value = null;\n    }).catch((error) => {\n      if (promise.cancelled) {\n        return nuxt._asyncDataPromises[key];\n      }\n      asyncData.error.value = error;\n      asyncData.data.value = unref(options.default?.() ?? null);\n    }).finally(() => {\n      if (promise.cancelled) {\n        return;\n      }\n      asyncData.pending.value = false;\n      nuxt.payload.data[key] = asyncData.data.value;\n      if (asyncData.error.value) {\n        nuxt.payload._errors[key] = createError(asyncData.error.value);\n      }\n      delete nuxt._asyncDataPromises[key];\n    });\n    nuxt._asyncDataPromises[key] = promise;\n    return nuxt._asyncDataPromises[key];\n  };\n  const initialFetch = () => asyncData.refresh({ _initial: true });\n  const fetchOnServer = options.server !== false && nuxt.payload.serverRendered;\n  if (process.server && fetchOnServer && options.immediate) {\n    const promise = initialFetch();\n    if (getCurrentInstance()) {\n      onServerPrefetch(() => promise);\n    } else {\n      nuxt.hook(\"app:created\", () => promise);\n    }\n  }\n  if (process.client) {\n    const instance = getCurrentInstance();\n    if (instance && !instance._nuxtOnBeforeMountCbs) {\n      instance._nuxtOnBeforeMountCbs = [];\n      const cbs = instance._nuxtOnBeforeMountCbs;\n      if (instance) {\n        onBeforeMount(() => {\n          cbs.forEach((cb) => {\n            cb();\n          });\n          cbs.splice(0, cbs.length);\n        });\n        onUnmounted(() => cbs.splice(0, cbs.length));\n      }\n    }\n    if (fetchOnServer && nuxt.isHydrating && hasCachedData()) {\n      asyncData.pending.value = false;\n    } else if (instance && (nuxt.payload.serverRendered && nuxt.isHydrating || options.lazy) && options.immediate) {\n      instance._nuxtOnBeforeMountCbs.push(initialFetch);\n    } else if (options.immediate) {\n      initialFetch();\n    }\n    if (options.watch) {\n      watch(options.watch, () => asyncData.refresh());\n    }\n    const off = nuxt.hook(\"app:data:refresh\", (keys) => {\n      if (!keys || keys.includes(key)) {\n        return asyncData.refresh();\n      }\n    });\n    if (instance) {\n      onUnmounted(off);\n    }\n  }\n  const asyncDataPromise = Promise.resolve(nuxt._asyncDataPromises[key]).then(() => asyncData);\n  Object.assign(asyncDataPromise, asyncData);\n  return asyncDataPromise;\n}\nexport function useLazyAsyncData(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [key, handler, options] = args;\n  return useAsyncData(key, handler, { ...options, lazy: true }, null);\n}\nexport function useNuxtData(key) {\n  const nuxt = useNuxtApp();\n  if (!(key in nuxt.payload.data)) {\n    nuxt.payload.data[key] = null;\n  }\n  return {\n    data: toRef(nuxt.payload.data, key)\n  };\n}\nexport async function refreshNuxtData(keys) {\n  if (process.server) {\n    return Promise.resolve();\n  }\n  const _keys = keys ? Array.isArray(keys) ? keys : [keys] : void 0;\n  await useNuxtApp().hooks.callHookParallel(\"app:data:refresh\", _keys);\n}\nexport function clearNuxtData(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.data);\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : Array.isArray(keys) ? keys : [keys];\n  for (const key of _keys) {\n    if (key in nuxtApp.payload.data) {\n      nuxtApp.payload.data[key] = void 0;\n    }\n    if (key in nuxtApp.payload._errors) {\n      nuxtApp.payload._errors[key] = void 0;\n    }\n    if (nuxtApp._asyncData[key]) {\n      nuxtApp._asyncData[key].data.value = void 0;\n      nuxtApp._asyncData[key].error.value = void 0;\n      nuxtApp._asyncData[key].pending.value = false;\n    }\n    if (key in nuxtApp._asyncDataPromises) {\n      nuxtApp._asyncDataPromises[key] = void 0;\n    }\n  }\n}\nfunction pick(obj, keys) {\n  const newObj = {};\n  for (const key of keys) {\n    newObj[key] = obj[key];\n  }\n  return newObj;\n}\n","import { defineStore, storeToRefs } from 'pinia'  \r\nimport { usePedidoStore } from '@/stores/pedido';   \r\nimport { Pedido } from '~~/types/interfaces'; \r\n\r\nexport const useActualizarStore = defineStore\r\n('actualizar', \r\n{ \r\n    state: () => ({\r\n        orden: [], \r\n    } ), \r\n    getters: { \r\n    },\r\n    actions: {  \r\n        async onCancelar() { \r\n            const storePedido = usePedidoStore(); \r\n            const { updateItem  } = useDirectusItems();    \r\n            // Submit values to API...   \r\n            try {\r\n                var status = {  status: 'Cancelado'  }   // var newItem = { status: \"Draft\" };\r\n                await updateItem<Pedido>({ \r\n                    collection: \"pedidos_hertz\",\r\n                    id: storePedido.pedido.pedidos_id,\r\n                    item: status });  \r\n                    await refreshNuxtData()\r\n                    window.location.reload()\r\n            } catch (e) { \r\n                    console.log('error') \r\n            } \r\n        }, \r\n    }\r\n}) "],"names":[],"mappings":";;;;;;AAoJA,eAAA,gBAAA,MAAA;AACA;AACA,WAAA,QAAA;EACA;AAGA;ACtJO,MAAA,qBAAA;AAAA,EAA2B;AAAA,EACjC;AAAA,IACD,OAAA,OAAA;AAAA,MACkB,OAAA,CAAA;AAAA,IACF;AAAA,IACZ,SAAA,CAAA;AAAA,IAEA,SAAA;AAAA,MACS,MAAA,aAAA;AAED,cAAA,cAAA;AACA,cAAA,EAAA,eAAA;AAEA,YAAA;AACI,cAAA,SAAA,EAAA,QAAA;AACA,gBAAA,WAAA;AAAA,YAAyB,YAAA;AAAA,YACT,IAAA,YAAA,OAAA;AAAA,YACW,MAAA;AAAA,UACjB,CAAA;AACN,gBAAA,gBAAA;AACA,iBAAA,SAAA;QAAuB,SAAA,GAAA;AAEvB,kBAAA,IAAA,OAAA;AAAA,QAAmB;AAAA,MAC3B;AAAA,IACJ;AAAA,EACJ;AACH;","x_google_ignoreList":[0]}